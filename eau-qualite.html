<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="V√©rifiez la qualit√© de l'eau du robinet dans votre commune">
    <title>Qualit√© de l'Eau - France</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    <style>
        /* ===== BASIC STYLING ===== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        /* ===== HEADER ===== */
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        .subtitle {
            color: rgba(255,255,255,0.8);
            text-align: center;
            margin-bottom: 40px;
        }

        /* ===== SEARCH BOX ===== */
        .search-box {
            background: white;
            padding: 30px;
            border-radius: 35px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .search-form {
            display: flex;
            gap: 10px;
        }

        .search-input {
            flex: 1;
            padding: 15px 20px;
            font-size: 1.1rem;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            outline: none;
            transition: border-color 0.3s;
        }

        .search-input:focus {
            border-color: #667eea;
        }

        .search-button {
            padding: 15px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        .search-button:hover {
            background: #5a6fd6;
        }

        .search-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* ===== RESULTS AREA ===== */
        .results {
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: none; /* Hidden until we have results */
        }

        .results.visible {
            display: block;
        }

        .results h2 {
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 0;
        }

        .network-info {
            color: #666;
            font-size: 0.9rem;
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #fee;
            color: #c00;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        /* ===== DATA CARDS ===== */
        .indicator-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .indicator-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .indicator-card.conforme {
            border-left-color: #28a745;
        }

        .indicator-card.non-conforme {
            border-left-color: #dc3545;
        }

        .indicator-card.info {
            border-left-color: #667eea;
        }

        .indicator-card.data-error {
            border-left-color: #6c757d;
            background: #f8f9fa;
        }

        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-top: 5px;
        }

        .status-badge.conforme {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.non-conforme {
            background: #f8d7da;
            color: #721c24;
        }

        .status-badge.info {
            background: #e7f1ff;
            color: #004085;
        }

        .status-badge.data-error {
            background: #e9ecef;
            color: #6c757d;
        }

        .indicator-note {
            font-size: 0.75rem;
            color: #999;
            margin-top: 5px;
        }

        .sparkline-container {
            margin-top: 10px;
            margin-bottom: 5px;
        }

        .sparkline {
            display: block;
        }

        .sparkline .spark-point {
            opacity: 1;
        }

        .sparkline-dates {
            font-size: 0.65rem;
            color: #aaa;
            margin-top: 2px;
        }

        .gauge-container {
            margin-top: 10px;
            margin-bottom: 5px;
            display: flex;
            justify-content: center;
        }
        .gauge-container svg {
            display: block;
            overflow: visible;
        }

        .source-link {
            margin-top: 20px;
            font-size: 0.75rem;
            color: #888;
        }

        .source-link a {
            color: #667eea;
        }

        /* ===== SUMMARY BADGE ===== */
        .summary-badge {
            padding: 15px 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .summary-badge.good {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 2px solid #28a745;
        }

        .summary-badge.warning {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%);
            border: 2px solid #ffc107;
        }

        .summary-badge.bad {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            border: 2px solid #dc3545;
        }

        .summary-badge.data-error {
            background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
            border: 2px solid #6c757d;
        }

        .summary-icon {
            font-size: 2rem;
        }

        .summary-content {
            flex: 1;
        }

        .summary-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: #333;
            margin-bottom: 4px;
        }

        .summary-details {
            font-size: 0.85rem;
            color: #666;
        }

        .data-warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            margin-bottom: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.85rem;
            color: #856404;
        }

        .indicator-name {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 5px;
        }

        .indicator-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
        }

        .indicator-unit {
            font-size: 0.9rem;
            color: #888;
        }

        .indicator-limit {
            font-size: 0.75rem;
            color: #999;
            margin-top: 5px;
        }

        .last-update {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            font-size: 0.85rem;
            color: #888;
        }

        /* ===== RESPONSIVE: MOBILE ===== */
        @media (max-width: 600px) {
            body {
                padding: 20px 10px;
            }

            h1 {
                font-size: 1.8rem;
            }

            .subtitle {
                font-size: 0.9rem;
                margin-bottom: 25px;
            }

            .search-box {
                padding: 20px 15px;
                border-radius: 20px;
            }

            .search-form {
                flex-direction: column;
            }

            .search-input {
                padding: 12px 15px;
                font-size: 1rem;
            }

            .search-button {
                padding: 12px 20px;
                font-size: 1rem;
            }

            .results {
                padding: 20px 15px;
                border-radius: 12px;
            }

            .results h2 {
                font-size: 1.3rem;
            }

            .indicator-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .indicator-card {
                padding: 15px;
            }

            .indicator-value {
                font-size: 1.3rem;
            }

            .sparkline-container svg {
                width: 100%;
                max-width: 150px;
            }

            .gauge-container svg {
                max-width: 140px;
            }

            .source-link {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíß Qualit√© de l'Eau</h1>
        <p class="subtitle">V√©rifiez la qualit√© de l'eau du robinet dans votre commune</p>

        <!-- SEARCH BOX -->
        <div class="search-box">
            <form class="search-form" id="searchForm">
                <input
                    type="text"
                    class="search-input"
                    id="cityInput"
                    placeholder="Entrez le nom de votre commune (ex: Lyon, Bordeaux...)"
                    required
                >
                <button type="submit" class="search-button" id="searchButton">
                    Rechercher
                </button>
            </form>
        </div>

        <!-- RESULTS AREA -->
        <div class="results" id="results">
            <!-- Results will be inserted here by JavaScript -->
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        // Base URL for the Hub'Eau API
        const API_BASE = 'https://hubeau.eaufrance.fr/api/v1/qualite_eau_potable';

        // Key water quality parameters to display
        // Official limits from: Arr√™t√© du 11 janvier 2007 (modified 30 d√©cembre 2022)
        // Source: https://www.legifrance.gouv.fr/loda/id/JORFTEXT000000465574
        const KEY_PARAMETERS = {
            // === Parameters with LEGAL LIMITS (health-related) ===
            // validMin/validMax = physically possible range (for data validation)
            '1340': { name: 'Nitrates', unit: 'mg/L', limit: 50, hasLimit: true, validMin: 0, validMax: 500 },
            '1350': { name: 'Nitrites', unit: 'mg/L', limit: 0.5, hasLimit: true, validMin: 0, validMax: 50 },
            '1302': { name: 'Chlorures', unit: 'mg/L', limit: 250, hasLimit: true, validMin: 0, validMax: 5000 },
            '1338': { name: 'Sulfates', unit: 'mg/L', limit: 250, hasLimit: true, validMin: 0, validMax: 2000 },
            '1347': {
                name: 'pH',
                unit: '',
                limitMin: 6.5,
                limitMax: 9,
                hasLimit: true,
                validMin: 0,
                validMax: 14,
                // Taste notes for out-of-range but valid values
                tasteNotes: {
                    low: { max: 6.5, note: 'Go√ªt l√©g√®rement acide possible' },
                    high: { min: 9, note: 'Go√ªt amer ou savonneux possible' }
                }
            },
            // === Parameters WITHOUT limits (informational only) ===
            // These minerals are beneficial - no health risk
            '1305': {
                name: 'Calcium',
                unit: 'mg/L',
                hasLimit: false,
                richThreshold: 120,  // "Riche en calcium" if above
                infoType: 'mineral'
            },
            '1319': {
                name: 'Magn√©sium',
                unit: 'mg/L',
                hasLimit: false,
                richThreshold: 56,  // "Riche en magn√©sium" if above
                infoType: 'mineral'
            },
            '1303': {
                name: 'Potassium',
                unit: 'mg/L',
                hasLimit: false,
                infoType: 'mineral'
            },
            '1372': {
                name: 'Duret√© (TH)',
                unit: '¬∞f',
                hasLimit: false,
                infoType: 'hardness',
                // Ranges: 0-8 tr√®s douce, 8-15 id√©ale, 15-25 acceptable, 25-30 moyennement dure, >30 dure
                ranges: [
                    { max: 8, label: 'tr√®s douce', note: 'Peut corroder les canalisations' },
                    { max: 15, label: 'id√©ale', note: 'Bon √©quilibre min√©raux/calcaire' },
                    { max: 25, label: 'acceptable', note: 'L√©g√®rement calcaire' },
                    { max: 30, label: 'moyennement dure', note: 'D√©p√¥ts possibles' },
                    { max: Infinity, label: 'dure', note: 'Risque de tartre' }
                ]
            },
        };

        // ===== DOM ELEMENTS =====
        const searchForm = document.getElementById('searchForm');
        const cityInput = document.getElementById('cityInput');
        const searchButton = document.getElementById('searchButton');
        const resultsDiv = document.getElementById('results');

        // ===== EVENT LISTENER =====
        searchForm.addEventListener('submit', async (e) => {
            e.preventDefault(); // Don't reload the page
            const cityName = cityInput.value.trim();
            if (cityName) {
                await searchCity(cityName);
            }
        });

        // ===== MAIN SEARCH FUNCTION =====
        async function searchCity(cityName) {
            // Show loading state
            resultsDiv.classList.add('visible');
            resultsDiv.innerHTML = '<div class="loading">üîç Recherche en cours...</div>';
            searchButton.disabled = true;

            try {
                // Step 1: Find the commune in the API
                const communeResponse = await fetch(
                    `${API_BASE}/communes_udi?nom_commune=${encodeURIComponent(cityName)}&size=1`
                );
                const communeData = await communeResponse.json();

                if (!communeData.data || communeData.data.length === 0) {
                    throw new Error(`Commune "${cityName}" non trouv√©e. V√©rifiez l'orthographe.`);
                }

                const commune = communeData.data[0];
                const codeCommune = commune.code_commune;
                const nomCommune = commune.nom_commune;
                const nomReseau = commune.nom_reseau;
                const nomQuartier = commune.nom_quartier !== '-' ? commune.nom_quartier : null;

                // Step 2: Get water quality results for this commune
                const resultsResponse = await fetch(
                    `${API_BASE}/resultats_dis?code_commune=${codeCommune}&size=200`
                );
                const resultsData = await resultsResponse.json();

                if (!resultsData.data || resultsData.data.length === 0) {
                    throw new Error(`Pas de donn√©es disponibles pour ${nomCommune}.`);
                }

                // Step 3: Display the results (use original search term for header)
                displayResults(cityName, nomReseau, nomQuartier, resultsData.data);

            } catch (error) {
                resultsDiv.innerHTML = `<div class="error">‚ùå ${error.message}</div>`;
            } finally {
                searchButton.disabled = false;
            }
        }

        // ===== DISPLAY RESULTS =====
        function displayResults(searchedCity, networkName, quarterName, data) {
            // Group ALL results by parameter (for sparklines) and track the latest
            const historyByParam = {};
            const latestByParam = {};
            let mostRecentDate = null;

            for (const result of data) {
                const code = result.code_parametre;
                const date = new Date(result.date_prelevement);
                const value = result.resultat_numerique;

                // Skip if no numeric value
                if (value === null || value === undefined) continue;

                // Track most recent date overall
                if (!mostRecentDate || date > mostRecentDate) {
                    mostRecentDate = date;
                }

                // Store all results for history
                if (!historyByParam[code]) {
                    historyByParam[code] = [];
                }
                historyByParam[code].push({ date, value });

                // Keep track of the most recent result
                if (!latestByParam[code] || date > new Date(latestByParam[code].date_prelevement)) {
                    latestByParam[code] = result;
                }
            }

            // Sort history by date for each parameter
            for (const code of Object.keys(historyByParam)) {
                historyByParam[code].sort((a, b) => a.date - b.date);
            }

            // Build the HTML and track issues for summary
            let cardsHtml = '';
            const issues = [];        // Non-conforme parameters
            const dataErrors = [];    // Impossible values (bad API data)
            const qualityMetrics = {  // Track quality indicators
                allBelowHalf: true,   // All regulated params < 50% of limit
                allBelow80: true,     // All regulated params < 80% of limit
                nitratesLow: false,   // Nitrates < 25 mg/L
                idealHardness: false, // TH between 8-15¬∞f
                hasGoodMinerals: false // Good calcium or magnesium
            };

            for (const [code, info] of Object.entries(KEY_PARAMETERS)) {
                const result = latestByParam[code];
                if (result && result.resultat_numerique !== null) {
                    const value = result.resultat_numerique;

                    // Check for impossible values (data validation)
                    const isDataError = checkDataError(value, info);
                    if (isDataError) {
                        dataErrors.push({
                            name: info.name,
                            value: value,
                            message: isDataError
                        });
                    }

                    const status = isDataError ? 'data-error' : getStatus(value, info);

                    // Track non-conforme parameters for summary
                    if (status === 'non-conforme' && !isDataError) {
                        issues.push(info.name);
                    }

                    // Track quality metrics (only for valid data)
                    if (!isDataError) {
                        // Check regulated parameters vs limits
                        if (info.hasLimit && info.limit) {
                            const percentOfLimit = (value / info.limit) * 100;
                            if (percentOfLimit >= 50) qualityMetrics.allBelowHalf = false;
                            if (percentOfLimit >= 80) qualityMetrics.allBelow80 = false;
                        }
                        // Nitrates specifically
                        if (code === '1340' && value < 25) {
                            qualityMetrics.nitratesLow = true;
                        }
                        // Hardness (TH) - ideal range
                        if (code === '1372' && value >= 8 && value <= 15) {
                            qualityMetrics.idealHardness = true;
                        }
                        // Good minerals (Calcium > 60 or Magnesium > 20)
                        if (code === '1305' && value >= 60) {
                            qualityMetrics.hasGoodMinerals = true;
                        }
                        if (code === '1319' && value >= 20) {
                            qualityMetrics.hasGoodMinerals = true;
                        }
                    }

                    // Build limit text
                    let limitText = '';
                    if (info.limitMin !== undefined && info.limitMax !== undefined) {
                        limitText = `Limite: ${info.limitMin} - ${info.limitMax}`;
                    } else if (info.limit) {
                        limitText = `Limite: ${info.limit} ${info.unit}`;
                    }

                    // Build status badge and info label
                    let statusBadge = '';
                    let infoNote = '';

                    if (isDataError) {
                        // Data error: show as inconsistent value
                        statusBadge = `<span class="status-badge data-error">valeur incoh√©rente</span>`;
                        infoNote = `<div class="indicator-note" style="color: #6c757d;">${isDataError}</div>`;
                    } else if (info.hasLimit) {
                        // Parameters with legal limits: show conforme/non conforme
                        const badgeText = status === 'conforme' ? 'conforme' : 'non conforme';
                        statusBadge = `<span class="status-badge ${status}">${badgeText}</span>`;

                        // Add taste note for pH if out of range but valid
                        if (info.tasteNotes) {
                            if (info.tasteNotes.low && value < info.tasteNotes.low.max) {
                                infoNote = `<div class="indicator-note">${info.tasteNotes.low.note}</div>`;
                            } else if (info.tasteNotes.high && value > info.tasteNotes.high.min) {
                                infoNote = `<div class="indicator-note">${info.tasteNotes.high.note}</div>`;
                            }
                        }
                    } else {
                        // Informational parameters: show mineral/hardness info
                        const infoLabel = getInfoLabel(value, info);
                        if (infoLabel) {
                            statusBadge = `<span class="status-badge info">${infoLabel.label}</span>`;
                            infoNote = `<div class="indicator-note">${infoLabel.note}</div>`;
                        }
                    }

                    // Generate gauge for regulated parameters
                    const gaugeHtml = info.hasLimit && !isDataError ? generateGauge(value, info) : '';

                    // Generate sparkline if we have history
                    const history = historyByParam[code];
                    const sparklineHtml = generateSparkline(history, info);

                    cardsHtml += `
                        <div class="indicator-card ${status}">
                            <div class="indicator-name">${info.name}</div>
                            <div class="indicator-value">
                                ${value} <span class="indicator-unit">${info.unit}</span>
                            </div>
                            ${limitText ? `<div class="indicator-limit">${limitText}</div>` : ''}
                            ${infoNote}
                            ${gaugeHtml}
                            ${sparklineHtml}
                            ${statusBadge}
                        </div>
                    `;
                }
            }

            // Build summary badge
            const summaryHtml = buildSummary(issues, dataErrors, qualityMetrics);

            // If no cards, show a message
            if (!cardsHtml) {
                cardsHtml = '<p>Aucun indicateur cl√© disponible pour cette commune.</p>';
            }

            // Build header with searched city (capitalize first letter)
            const displayCity = searchedCity.charAt(0).toUpperCase() + searchedCity.slice(1).toLowerCase();
            let headerHtml = `<h2>üìç ${displayCity}</h2>`;

            // Show network dependency info
            let networkInfo = `Cette commune d√©pend du site d'analyse <strong>${networkName}</strong>`;
            if (quarterName) {
                networkInfo += ` (${quarterName})`;
            }

            resultsDiv.innerHTML = `
                ${headerHtml}
                <div class="network-info">${networkInfo}</div>
                ${summaryHtml}
                <div class="indicator-grid">
                    ${cardsHtml}
                </div>
                <div class="last-update">
                    Derni√®re analyse: ${mostRecentDate ? mostRecentDate.toLocaleDateString('fr-FR') : 'Inconnue'}
                </div>
                <div class="source-link">
                    Valeurs de vigilance des eaux destin√©es √† la consommation humaine: <a href="https://www.legifrance.gouv.fr/loda/id/JORFTEXT000000465574" target="_blank">Arr√™t√© du 11 janvier 2007</a>
                </div>
            `;
        }

        // ===== HELPER: Check for impossible data values =====
        function checkDataError(value, paramInfo) {
            // Check if value is within physically possible range
            if (paramInfo.validMin !== undefined && value < paramInfo.validMin) {
                return `Valeur impossible (min: ${paramInfo.validMin})`;
            }
            if (paramInfo.validMax !== undefined && value > paramInfo.validMax) {
                return `Valeur impossible (${paramInfo.name} max: ${paramInfo.validMax})`;
            }
            return null; // No error
        }

        // ===== HELPER: Build summary badge =====
        function buildSummary(issues, dataErrors, qualityMetrics) {
            let summaryClass, icon, title, details;

            // Real health issues take priority
            if (issues.length > 0) {
                if (issues.length === 1) {
                    // One real issue
                    summaryClass = 'warning';
                    icon = '‚ö†Ô∏è';
                    title = `Attention: ${issues[0]} √©lev√©`;
                    details = `${issues[0]} d√©passe la limite r√©glementaire. Consultez les d√©tails ci-dessous.`;
                } else {
                    // Multiple real issues
                    summaryClass = 'warning';
                    icon = '‚ö†Ô∏è';
                    title = 'Plusieurs param√®tres hors normes';
                    details = `${issues.join(' et ')} d√©passent les limites r√©glementaires. Consultez votre mairie ou l'ARS.`;
                }
            } else {
                // No real issues - determine quality level (data errors don't block this)
                summaryClass = 'good';
                icon = '‚úÖ';

                // Build quality details
                const qualityPoints = [];

                // Excellente: all params < 50% of limit + good indicators
                if (qualityMetrics.allBelowHalf && (qualityMetrics.nitratesLow || qualityMetrics.idealHardness || qualityMetrics.hasGoodMinerals)) {
                    title = 'Eau potable - Excellente qualit√©';
                    if (qualityMetrics.nitratesLow) qualityPoints.push('faible teneur en nitrates');
                    if (qualityMetrics.idealHardness) qualityPoints.push('duret√© id√©ale');
                    if (qualityMetrics.hasGoodMinerals) qualityPoints.push('bon apport min√©ral');
                    details = qualityPoints.length > 0
                        ? `Tous les param√®tres bien en dessous des limites. ${qualityPoints.join(', ').charAt(0).toUpperCase() + qualityPoints.join(', ').slice(1)}.`
                        : 'Tous les param√®tres bien en dessous des limites r√©glementaires.';
                }
                // Bonne: all params < 80% of limit
                else if (qualityMetrics.allBelow80) {
                    title = 'Eau potable - Bonne qualit√©';
                    details = 'Tous les param√®tres r√©glement√©s sont conformes aux normes fran√ßaises.';
                }
                // Correcte: all params conform but some close to limits
                else {
                    title = 'Eau potable';
                    details = 'Conforme aux normes. Certains param√®tres proches des limites r√©glementaires.';
                }

                // Add note about data errors if any
                if (dataErrors.length > 0) {
                    details += ' Certaines mesures semblent incorrectes.';
                }
            }

            return `
                <div class="summary-badge ${summaryClass}">
                    <div class="summary-icon">${icon}</div>
                    <div class="summary-content">
                        <div class="summary-title">${title}</div>
                        <div class="summary-details">${details}</div>
                    </div>
                </div>
            `;
        }

        // ===== HELPER: Determine conformity status =====
        // Based on official French limits (Arr√™t√© du 11 janvier 2007)
        function getStatus(value, paramInfo) {
            if (!paramInfo.hasLimit) return 'info'; // No legal limit = informational only

            // Special handling for pH (range limit)
            if (paramInfo.limitMin !== undefined && paramInfo.limitMax !== undefined) {
                if (value >= paramInfo.limitMin && value <= paramInfo.limitMax) {
                    return 'conforme';
                }
                return 'non-conforme';
            }

            // Standard single limit (must be <= limit)
            if (value <= paramInfo.limit) {
                return 'conforme';
            }
            return 'non-conforme';
        }

        // ===== HELPER: Get informational label for minerals =====
        function getInfoLabel(value, paramInfo) {
            if (paramInfo.hasLimit) return null; // Only for informational parameters

            // Hardness (Duret√©) - has specific ranges
            if (paramInfo.infoType === 'hardness' && paramInfo.ranges) {
                for (const range of paramInfo.ranges) {
                    if (value <= range.max) {
                        return {
                            label: range.label,
                            note: range.note
                        };
                    }
                }
            }

            // Minerals (Calcium, Magn√©sium, Potassium)
            if (paramInfo.infoType === 'mineral') {
                let label = 'min√©ral b√©n√©fique';
                let note = 'Sans risque pour la sant√©';

                // Check if water is "rich" in this mineral
                if (paramInfo.richThreshold && value > paramInfo.richThreshold) {
                    note = `Eau riche en ${paramInfo.name.toLowerCase()}`;
                }

                return { label, note };
            }

            return null;
        }

        // ===== HELPER: Generate sparkline SVG =====
        function generateSparkline(history, paramInfo) {
            // Need at least 2 points to draw a line
            if (!history || history.length < 2) return '';

            const width = 150;
            const height = 40;
            const padding = 5;

            // Get min/max values for scaling
            const values = history.map(h => h.value);
            let minVal = Math.min(...values);
            let maxVal = Math.max(...values);

            // Include limit in scale if parameter has one
            const limit = paramInfo.limit;
            if (limit !== undefined) {
                maxVal = Math.max(maxVal, limit * 1.1); // Show limit with some margin
                minVal = Math.min(minVal, 0);
            }

            // Avoid division by zero if all values are the same
            if (maxVal === minVal) {
                maxVal = minVal + 1;
            }

            // Calculate points for the sparkline
            const points = history.map((h, i) => {
                const x = padding + (i / (history.length - 1)) * (width - 2 * padding);
                const y = height - padding - ((h.value - minVal) / (maxVal - minVal)) * (height - 2 * padding);
                return { x, y, value: h.value, date: h.date };
            });

            // Build the path
            const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');

            // Build limit line if applicable
            let limitLine = '';
            if (limit !== undefined) {
                const limitY = height - padding - ((limit - minVal) / (maxVal - minVal)) * (height - 2 * padding);
                limitLine = `<line x1="${padding}" y1="${limitY}" x2="${width - padding}" y2="${limitY}"
                    stroke="#dc3545" stroke-width="1" stroke-dasharray="3,2" opacity="0.7"/>`;
            }

            // Show key dots: first, last, min, max (works on mobile without hover)
            const firstPoint = points[0];
            const lastPoint = points[points.length - 1];
            const minPoint = points.reduce((min, p) => p.value < min.value ? p : min, points[0]);
            const maxPoint = points.reduce((max, p) => p.value > max.value ? p : max, points[0]);

            // Use Set-like filtering to avoid duplicate dots at same position
            const keyPoints = [firstPoint, lastPoint, minPoint, maxPoint];
            const uniquePoints = keyPoints.filter((p, i) =>
                keyPoints.findIndex(other => other.x === p.x) === i
            );

            const circles = uniquePoints.map(p => {
                const dateStr = p.date.toLocaleDateString('fr-FR');
                return `<circle cx="${p.x}" cy="${p.y}" r="3" fill="#667eea" class="spark-point">
                    <title>${dateStr}: ${p.value} ${paramInfo.unit}</title>
                </circle>`;
            }).join('');

            // Date range text with count
            const firstDate = history[0].date.toLocaleDateString('fr-FR', { month: 'short', year: 'numeric' });
            const lastDate = history[history.length - 1].date.toLocaleDateString('fr-FR', { month: 'short', year: 'numeric' });
            const count = history.length;

            return `
                <div class="sparkline-container">
                    <svg width="${width}" height="${height}" class="sparkline">
                        ${limitLine}
                        <path d="${pathD}" fill="none" stroke="#667eea" stroke-width="2"/>
                        ${circles}
                    </svg>
                    <div class="sparkline-dates">${firstDate} ‚Üí ${lastDate} (${count} mesures)</div>
                </div>
            `;
        }

        // ===== HELPER: Gauge color based on proximity to limit =====
        function getGaugeColor(percentOfLimit) {
            if (percentOfLimit < 50) return '#28a745';   // Green
            if (percentOfLimit < 80) return '#ffc107';   // Yellow
            if (percentOfLimit < 100) return '#fd7e14';  // Orange
            return '#dc3545';                            // Red
        }

        // ===== HELPER: Standard gauge for Nitrates, Nitrites, Chlorures, Sulfates =====
        function generateStandardGauge(value, paramInfo) {
            const w = 140, h = 80;
            const cx = 70, cy = 70, r = 55;
            const limit = paramInfo.limit;
            // Scale goes from 0 to limit * 1.5 so the limit mark falls at 2/3 of arc
            const scaleMax = limit * 1.5;
            const percent = Math.min(value / scaleMax, 1); // cap at 100% of arc
            const percentOfLimit = (value / limit) * 100;
            const color = getGaugeColor(percentOfLimit);

            // Arc angles: 180¬∞ (left) to 0¬∞ (right) ‚Äî a half-circle
            const startAngle = Math.PI;       // 180¬∞
            const endAngle = 0;               // 0¬∞
            const totalSweep = Math.PI;       // 180¬∞ total

            // Background arc (full half-circle)
            const bgX1 = cx + r * Math.cos(startAngle);
            const bgY1 = cy - r * Math.sin(startAngle);
            const bgX2 = cx + r * Math.cos(endAngle);
            const bgY2 = cy - r * Math.sin(endAngle);
            const bgPath = `M ${bgX1} ${bgY1} A ${r} ${r} 0 1 1 ${bgX2} ${bgY2}`;

            // Value arc
            let valuePath = '';
            if (percent > 0.01) { // avoid SVG artifact for tiny values
                const valueAngle = startAngle - percent * totalSweep;
                const vx = cx + r * Math.cos(valueAngle);
                const vy = cy - r * Math.sin(valueAngle);
                const largeArc = percent > 0.5 ? 1 : 0;
                valuePath = `<path d="M ${bgX1} ${bgY1} A ${r} ${r} 0 ${largeArc} 1 ${vx} ${vy}"
                    fill="none" stroke="${color}" stroke-width="10" stroke-linecap="round"/>`;
            }

            // Limit tick mark at 2/3 of arc
            const limitFraction = limit / scaleMax; // = 2/3
            const limitAngle = startAngle - limitFraction * totalSweep;
            const tickInner = r - 8;
            const tickOuter = r + 8;
            const tx1 = cx + tickInner * Math.cos(limitAngle);
            const ty1 = cy - tickInner * Math.sin(limitAngle);
            const tx2 = cx + tickOuter * Math.cos(limitAngle);
            const ty2 = cy - tickOuter * Math.sin(limitAngle);

            return `
                <div class="gauge-container">
                    <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
                        <path d="${bgPath}" fill="none" stroke="#e9ecef" stroke-width="10" stroke-linecap="round"/>
                        ${valuePath}
                        <line x1="${tx1}" y1="${ty1}" x2="${tx2}" y2="${ty2}"
                            stroke="#dc3545" stroke-width="2" opacity="0.6"/>
                        <text x="${cx}" y="${cy - 8}" text-anchor="middle"
                            font-size="16" font-weight="bold" fill="${color}">${value}</text>
                        <text x="${cx}" y="${cy + 6}" text-anchor="middle"
                            font-size="9" fill="#999">${paramInfo.unit}</text>
                    </svg>
                </div>`;
        }

        // ===== HELPER: pH gauge with green zone =====
        function generatePhGauge(value, paramInfo) {
            const w = 140, h = 80;
            const cx = 70, cy = 70, r = 55;
            const scaleMin = 0, scaleMax = 14;
            const totalSweep = Math.PI;
            const startAngle = Math.PI;

            // Background arc
            const bgX1 = cx + r * Math.cos(startAngle);
            const bgY1 = cy - r * Math.sin(startAngle);
            const bgX2 = cx + r * Math.cos(0);
            const bgY2 = cy - r * Math.sin(0);
            const bgPath = `M ${bgX1} ${bgY1} A ${r} ${r} 0 1 1 ${bgX2} ${bgY2}`;

            // Green zone arc (6.5 to 9)
            const zoneLowFrac = (paramInfo.limitMin - scaleMin) / (scaleMax - scaleMin);
            const zoneHighFrac = (paramInfo.limitMax - scaleMin) / (scaleMax - scaleMin);
            const zoneStartAngle = startAngle - zoneLowFrac * totalSweep;
            const zoneEndAngle = startAngle - zoneHighFrac * totalSweep;
            const zx1 = cx + r * Math.cos(zoneStartAngle);
            const zy1 = cy - r * Math.sin(zoneStartAngle);
            const zx2 = cx + r * Math.cos(zoneEndAngle);
            const zy2 = cy - r * Math.sin(zoneEndAngle);
            const zoneSweep = zoneHighFrac - zoneLowFrac;
            const zoneLargeArc = zoneSweep > 0.5 ? 1 : 0;
            const greenZone = `<path d="M ${zx1} ${zy1} A ${r} ${r} 0 ${zoneLargeArc} 1 ${zx2} ${zy2}"
                fill="none" stroke="rgba(40,167,69,0.3)" stroke-width="10" stroke-linecap="round"/>`;

            // Needle for current value
            const clampedValue = Math.max(scaleMin, Math.min(scaleMax, value));
            const valueFrac = (clampedValue - scaleMin) / (scaleMax - scaleMin);
            const needleAngle = startAngle - valueFrac * totalSweep;
            const needleLen = r - 5;
            const nx = cx + needleLen * Math.cos(needleAngle);
            const ny = cy - needleLen * Math.sin(needleAngle);
            const inZone = value >= paramInfo.limitMin && value <= paramInfo.limitMax;
            const needleColor = inZone ? '#28a745' : '#dc3545';

            return `
                <div class="gauge-container">
                    <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
                        <path d="${bgPath}" fill="none" stroke="#e9ecef" stroke-width="10" stroke-linecap="round"/>
                        ${greenZone}
                        <line x1="${cx}" y1="${cy}" x2="${nx}" y2="${ny}"
                            stroke="${needleColor}" stroke-width="2.5" stroke-linecap="round"/>
                        <circle cx="${cx}" cy="${cy}" r="3" fill="${needleColor}"/>
                        <text x="${cx}" y="${cy - 8}" text-anchor="middle"
                            font-size="16" font-weight="bold" fill="${needleColor}">${value}</text>
                        <text x="${cx}" y="${cy + 6}" text-anchor="middle"
                            font-size="9" fill="#999">pH</text>
                    </svg>
                </div>`;
        }

        // ===== HELPER: Dispatch to correct gauge type =====
        function generateGauge(value, paramInfo) {
            if (!paramInfo.hasLimit) return '';
            if (paramInfo.limitMin !== undefined) return generatePhGauge(value, paramInfo);
            return generateStandardGauge(value, paramInfo);
        }

        // ===== SERVICE WORKER REGISTRATION =====
        // Register service worker for offline support (PWA)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
